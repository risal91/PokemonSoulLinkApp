<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Soul Link Challenge</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.0/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.2/dist/socket.io.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
        }
        .container {
            max-width: 1200px;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .card {
            border-radius: 0.75rem;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }
        .card-header {
            background-color: #007bff;
            color: white;
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            font-weight: bold;
        }
        .table-responsive {
            margin-top: 1rem;
        }
        .table th, .table td {
            vertical-align: middle;
            text-align: center;
        }
        .table thead th {
            background-color: #e9ecef;
        }
        .form-control, .btn {
            border-radius: 0.375rem;
        }
        .alert {
            margin-top: 1rem;
        }
        .custom-select-wrapper {
            position: relative;
            width: 100%;
        }
        .custom-select-trigger {
            background-color: #fff;
            border: 1px solid #ced4da;
            border-radius: 0.375rem;
            padding: 0.375rem 0.75rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: calc(1.5em + 0.75rem + 2px); /* Angleichen an Bootstrap input Höhe */
        }
        .custom-select-trigger::after {
            content: '▼';
            font-size: 0.7em;
            margin-left: 0.5em;
            transition: transform 0.2s;
        }
        .custom-select-trigger.active::after {
            transform: rotate(180deg);
        }
        .custom-select-options {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ced4da;
            border-radius: 0.375rem;
            max-height: 200px;
            overflow-y: auto;
            width: 100%;
            z-index: 1000;
            display: none; /* Standardmäßig versteckt */
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }
        .custom-select-options.active {
            display: block; /* Zeigt die Optionen an, wenn aktiv */
        }
        .custom-select-option {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
        }
        .custom-select-option:hover {
            background-color: #e9ecef;
        }
        .custom-select-option.selected {
            background-color: #007bff;
            color: white;
        }
        .custom-select-search {
            width: calc(100% - 1.5rem);
            padding: 0.5rem;
            margin: 0.5rem 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.375rem;
            box-sizing: border-box;
            display: none; /* <-- FIX: Standardmäßig ausblenden */
        }
        .custom-select-options.active .custom-select-search {
            display: block; /* <-- FIX: Nur anzeigen, wenn Optionen aktiv sind */
        }

        /* Global Order & Level Caps Styling */
        .global-orders-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 1rem;
            padding: 15px;
            background-color: #f0f8ff; /* Light blue background */
            border-radius: 0.5rem;
            border: 1px solid #e0f0ff;
        }
        .global-order-button {
            padding: 10px 15px;
            border: 1px solid #007bff;
            border-radius: 0.375rem;
            background-color: #f8f9fa;
            color: #007bff;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            min-width: 100px; /* Ensure buttons have a minimum width */
            text-align: center;
        }
        .global-order-button.obtained {
            background-color: #28a745; /* Green for obtained */
            color: white;
            border-color: #28a745;
        }
        .global-order-button:hover:not(.obtained) {
            background-color: #e9ecef;
        }
        .level-cap-display {
            width: 100%;
            text-align: center;
            margin-top: 1rem;
            padding: 15px;
            background-color: #d4edda; /* Light green background */
            border-radius: 0.5rem;
            color: #155724;
            font-weight: bold;
            border: 1px solid #c3e6cb;
        }
        .error-message {
            color: red;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center my-4">Pokémon Soul Link Challenge</h1>

        <div class="d-flex justify-content-center mb-4">
            <a href="/summary" class="btn btn-info mx-2">Kurzansicht öffnen</a>
            <button class="btn btn-danger mx-2" onclick="confirmFullDbReset()">Datenbank vollständig zurücksetzen</button>
        </div>

        <div id="errorMessage" class="alert alert-danger d-none" role="alert">
            Ein Fehler ist aufgetreten.
        </div>
        <div id="successMessage" class="alert alert-success d-none" role="alert">
            Aktion erfolgreich!
        </div>

        <div class="card mb-4">
            <div class="card-header">Spielerverwaltung</div>
            <div class="card-body">
                <div class="input-group mb-3">
                    <input type="text" id="newPlayerName" class="form-control" placeholder="Neuer Spielername">
                    <button class="btn btn-primary" onclick="addPlayer()">Spieler hinzufügen</button>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header">Routenverwaltung</div>
            <div class="card-body">
                <div class="input-group mb-3">
                    <select id="newRouteName" class="form-select" data-placeholder="Route auswählen...">
                        <option></option>
                    </select>
                    <button class="btn btn-primary" onclick="addRoute()">Route hinzufügen</button>
                </div>
                <div class="input-group">
                    <select id="routeToRemove" class="form-select" data-placeholder="Route zum Entfernen auswählen...">
                        <option></option>
                    </select>
                    <button class="btn btn-danger" onclick="confirmClearRouteData()">Ausgewählte Route entfernen</button>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header">Pokémon-Fänge Übersicht</div>
            <div class="card-body">
                <button class="btn btn-danger mb-3" onclick="confirmResetAllData()">Alle Fänge & Routen-Status zurücksetzen</button>
                <div class="table-responsive">
                    <table class="table table-bordered" id="catchTable">
                        <thead>
                            <tr>
                                <th>ROUTE</th>
                                <th>STATUS</th>
                                <th>AKTIONEN</th>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header">Globale Orden & Level Caps</div>
            <div class="card-body">
                <div class="global-orders-container" id="globalOrdersContainer">
                    </div>
                <div class="level-cap-display" id="levelCapDisplay">
                    Aktuelles Level Cap: -- (Angepasst: --)
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header">Daten-Export & Import (String)</div>
            <div class="card-body">
                <div class="alert alert-info" role="alert">
                    Exportiert alle Daten (Datenbank und Konfigurationsdateien) als einen einzigen Text-String. Dieser String kann zur Sicherung kopiert und später zum Wiederherstellen der Daten eingefügt werden.
                </div>
                <div class="mb-3">
                    <button class="btn btn-success" onclick="exportAllDataAsString()">Alle Daten exportieren</button>
                </div>
                <div class="mb-3">
                    <label for="exportDataString" class="form-label">Exportierter Daten-String:</label>
                    <textarea id="exportDataString" class="form-control" rows="10" readonly placeholder="Exportierter Daten-String wird hier angezeigt..."></textarea>
                    <button class="btn btn-secondary mt-2" onclick="copyExportString()">String kopieren</button>
                </div>
                <hr>
                <div class="mb-3">
                    <label for="importDataString" class="form-label">Daten-String zum Importieren einfügen:</label>
                    <textarea id="importDataString" class="form-control" rows="10" placeholder="Fügen Sie hier den exportierten Daten-String ein..."></textarea>
                </div>
                <div class="input-group mb-3">
                    <input type="password" id="importPassword" class="form-control" placeholder="Passwort für Import (ImportJetzt)">
                    <button class="btn btn-warning" onclick="confirmImportDataAsString()">Daten importieren</button>
                </div>
                <div class="alert alert-warning mt-3" role="alert">
                    **ACHTUNG:** Das Importieren von Daten überschreibt alle aktuellen Daten in der Anwendung! Stellen Sie sicher, dass Sie einen gültigen und vertrauenswürdigen Daten-String verwenden. Das Standardpasswort ist `ImportJetzt`.
                </div>
            </div>
        </div>

    </div>

    <script>
        const socket = io();
        let players = [];
        let routes = [];
        let catches = [];
        let globalOrders = [];
        let levelCaps = [];
        let allPokemonNames = [];
        let allRouteNames = [];

        // --- Hilfsfunktionen für Nachrichten ---
        function showMessage(type, message) {
            const errorDiv = document.getElementById('errorMessage');
            const successDiv = document.getElementById('successMessage');

            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');

            if (type === 'error') {
                errorDiv.textContent = message;
                errorDiv.classList.remove('d-none');
            } else if (type === 'success') {
                successDiv.textContent = message;
                successDiv.classList.remove('d-none');
            }
            // Blende die Nachricht nach 5 Sekunden aus
            setTimeout(() => {
                errorDiv.classList.add('d-none');
                successDiv.classList.add('d-none');
            }, 5000);
        }

        // --- Daten laden und Tabelle rendern ---
        async function fetchDataAndRender() {
            try {
                const response = await fetch('/api/data');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                players = data.players;
                routes = data.routes;
                catches = data.catches;
                globalOrders = data.global_orders;
                levelCaps = data.level_caps;
                allPokemonNames = data.all_pokemon_names;
                allRouteNames = data.all_route_names;

                renderTable();
                renderGlobalOrders();
                renderLevelCap();
                populateRouteSelects();
                showMessage('success', 'Daten erfolgreich geladen.');

            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                showMessage('error', 'Fehler beim Laden der Daten. Server möglicherweise nicht erreichbar.');
            }
        }

        function renderTable() {
            const table = document.getElementById('catchTable');
            const thead = table.querySelector('thead tr');
            const tbody = table.querySelector('tbody');

            // Header rendern
            thead.innerHTML = '<th>ROUTE</th>';
            players.forEach(player => {
                thead.innerHTML += `<th>${player.name.toUpperCase()}</th>`;
            });
            thead.innerHTML += '<th>STATUS</th><th>AKTIONEN</th>';

            // Body rendern
            tbody.innerHTML = '';
            routes.forEach(route => {
                const row = tbody.insertRow();
                row.insertCell().textContent = route.name;

                players.forEach(player => {
                    const cell = row.insertCell();
                    const catchEntry = catches.find(c => c.player_id === player.id && c.route_id === route.id);
                    const pokemonName = catchEntry ? (catchEntry.pokemon_name || 'Pokémon eintragen') : 'Pokémon eintragen';
                    
                    // Erstelle den Custom Select
                    const customSelectHtml = createCustomSelect(player.id, route.id, pokemonName);
                    cell.innerHTML = customSelectHtml;
                });

                // Status-Zelle
                const statusCell = row.insertCell();
                statusCell.innerHTML = `
                    <div class="custom-select-wrapper status-select-wrapper">
                        <div class="custom-select-trigger status-trigger" data-route-id="${route.id}">
                            <span>${route.status || 'Status'}</span>
                            <input type="hidden" class="status-value" value="${route.status || ''}">
                        </div>
                        <div class="custom-select-options status-options">
                            <div class="custom-select-option" data-value="">Status</div>
                            <div class="custom-select-option" data-value="Abgeschlossen">Abgeschlossen</div>
                            <div class="custom-select-option" data-value="Laufend">Laufend</div>
                            <div class="custom-select-option" data-value="Ausstehend">Ausstehend</div>
                            <div class="custom-select-option" data-value="Fehlgeschlagen">Fehlgeschlagen</div>
                        </div>
                    </div>
                `;

                // Aktionen-Zelle
                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `<button class="btn btn-danger btn-sm" onclick="confirmClearRouteData(${route.id})">Clear Route Data</button>`;
            });

            // Initialisiere Custom Selects nach dem Rendern
            initializeCustomSelects();
            initializeStatusSelects();
        }

        function createCustomSelect(playerId, routeId, selectedPokemon) {
            const uniqueId = `select-${playerId}-${routeId}`;
            let optionsHtml = allPokemonNames.map(name => 
                `<div class="custom-select-option ${name === selectedPokemon ? 'selected' : ''}" data-value="${name}">${name}</div>`
            ).join('');

            // Option für "No Catch" hinzufügen
            optionsHtml = `<div class="custom-select-option ${selectedPokemon === 'No Catch' ? 'selected' : ''}" data-value="No Catch">No Catch</div>` + optionsHtml;

            return `
                <div class="custom-select-wrapper">
                    <div class="custom-select-trigger" data-player-id="${playerId}" data-route-id="${routeId}">
                        <span>${selectedPokemon}</span>
                        <input type="hidden" class="selected-value" value="${selectedPokemon}">
                    </div>
                    <div class="custom-select-options">
                        <input type="text" class="custom-select-search" placeholder="Suche Pokémon...">
                        ${optionsHtml}
                    </div>
                </div>
            `;
        }

        function initializeCustomSelects() {
            document.querySelectorAll('.custom-select-trigger').forEach(trigger => {
                // Verhindere doppelte Event-Listener
                if (trigger.dataset.initialized) return; 
                trigger.dataset.initialized = true;

                trigger.addEventListener('click', function() {
                    const wrapper = this.closest('.custom-select-wrapper');
                    const optionsDiv = wrapper.querySelector('.custom-select-options');
                    const searchInput = wrapper.querySelector('.custom-select-search');

                    // Schließe andere offene Selects
                    document.querySelectorAll('.custom-select-options.active').forEach(openOptions => {
                        if (openOptions !== optionsDiv) {
                            openOptions.classList.remove('active');
                            openOptions.previousElementSibling.classList.remove('active');
                        }
                    });

                    optionsDiv.classList.toggle('active');
                    this.classList.toggle('active');

                    if (optionsDiv.classList.contains('active')) {
                        searchInput.value = ''; // Suchfeld leeren beim Öffnen
                        filterOptions(searchInput); // Alle Optionen anzeigen
                        searchInput.focus();
                    }
                });
            });

            document.querySelectorAll('.custom-select-options').forEach(optionsDiv => {
                const searchInput = optionsDiv.querySelector('.custom-select-search');
                if (searchInput && !searchInput.dataset.initialized) {
                    searchInput.dataset.initialized = true;
                    searchInput.addEventListener('input', function() {
                        filterOptions(this);
                    });
                }

                optionsDiv.querySelectorAll('.custom-select-option').forEach(option => {
                    if (option.dataset.initialized) return;
                    option.dataset.initialized = true;

                    option.addEventListener('click', async function() {
                        const wrapper = this.closest('.custom-select-wrapper');
                        const trigger = wrapper.querySelector('.custom-select-trigger');
                        const displaySpan = trigger.querySelector('span');
                        const hiddenInput = trigger.querySelector('.selected-value');
                        const optionsDiv = wrapper.querySelector('.custom-select-options');

                        const playerId = trigger.dataset.playerId;
                        const routeId = trigger.dataset.routeId;
                        const pokemonName = this.dataset.value;

                        displaySpan.textContent = pokemonName;
                        hiddenInput.value = pokemonName;

                        // Entferne 'selected' von allen Optionen und füge es der geklickten hinzu
                        optionsDiv.querySelectorAll('.custom-select-option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');

                        optionsDiv.classList.remove('active');
                        trigger.classList.remove('active');

                        // API-Aufruf
                        try {
                            const response = await fetch('/api/update_catch', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ player_id: playerId, route_id: routeId, pokemon_name: pokemonName })
                            });
                            if (!response.ok) {
                                throw new Error('Fehler beim Aktualisieren des Fangs');
                            }
                            // SocketIO wird die UI aktualisieren
                        } catch (error) {
                            console.error('Fehler beim Aktualisieren des Fangs:', error);
                            showMessage('error', 'Fehler beim Aktualisieren des Fangs.');
                        }
                    });
                });
            });

            // Klick außerhalb des Selects schließen
            document.addEventListener('click', function(event) {
                document.querySelectorAll('.custom-select-wrapper').forEach(wrapper => {
                    if (!wrapper.contains(event.target)) {
                        const optionsDiv = wrapper.querySelector('.custom-select-options');
                        const trigger = wrapper.querySelector('.custom-select-trigger');
                        optionsDiv.classList.remove('active');
                        trigger.classList.remove('active');
                    }
                });
            });
        }

        function filterOptions(searchInput) {
            const filter = searchInput.value.toLowerCase();
            const optionsDiv = searchInput.closest('.custom-select-options');
            const options = optionsDiv.querySelectorAll('.custom-select-option');

            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(filter)) {
                    option.style.display = '';
                } else {
                    option.style.display = 'none';
                }
            });
        }

        function initializeStatusSelects() {
            document.querySelectorAll('.status-select-wrapper .custom-select-trigger').forEach(trigger => {
                if (trigger.dataset.initialized) return;
                trigger.dataset.initialized = true;

                trigger.addEventListener('click', function() {
                    const wrapper = this.closest('.status-select-wrapper');
                    const optionsDiv = wrapper.querySelector('.status-options');

                    document.querySelectorAll('.custom-select-options.active').forEach(openOptions => {
                        if (openOptions !== optionsDiv) {
                            openOptions.classList.remove('active');
                            openOptions.previousElementSibling.classList.remove('active');
                        }
                    });

                    optionsDiv.classList.toggle('active');
                    this.classList.toggle('active');
                });
            });

            document.querySelectorAll('.status-select-wrapper .custom-select-option').forEach(option => {
                if (option.dataset.initialized) return;
                option.dataset.initialized = true;

                option.addEventListener('click', async function() {
                    const wrapper = this.closest('.status-select-wrapper');
                    const trigger = wrapper.querySelector('.status-trigger');
                    const displaySpan = trigger.querySelector('span');
                    const hiddenInput = trigger.querySelector('.status-value');
                    const optionsDiv = wrapper.querySelector('.status-options');

                    const routeId = trigger.dataset.routeId;
                    const statusText = this.dataset.value;

                    displaySpan.textContent = statusText || 'Status'; // Zeige "Status" wenn leer
                    hiddenInput.value = statusText;

                    optionsDiv.classList.remove('active');
                    trigger.classList.remove('active');

                    try {
                        const response = await fetch('/api/update_route_status', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ route_id: routeId, status_text: statusText })
                        });
                        if (!response.ok) {
                            throw new Error('Fehler beim Aktualisieren des Routenstatus');
                        }
                        // SocketIO wird die UI aktualisieren
                    } catch (error) {
                        console.error('Fehler beim Aktualisieren des Routenstatus:', error);
                        showMessage('error', 'Fehler beim Aktualisieren des Routenstatus.');
                    }
                });
            });
        }

        function renderGlobalOrders() {
            const container = document.getElementById('globalOrdersContainer');
            container.innerHTML = ''; // Vorherige Buttons entfernen

            // Sortiere Orden nach order_number
            globalOrders.sort((a, b) => a.order_number - b.order_number);

            globalOrders.forEach(order => {
                const button = document.createElement('button');
                button.classList.add('global-order-button');
                if (order.is_obtained) {
                    button.classList.add('obtained');
                }
                button.textContent = `${order.order_number}. Arena`; // Oder anderer passender Text
                button.dataset.orderNumber = order.order_number;
                button.onclick = () => toggleGlobalOrder(order.order_number);
                container.appendChild(button);
            });
        }

        function renderLevelCap() {
            const display = document.getElementById('levelCapDisplay');
            const currentLevelCap = levelCaps.find(lc => lc.is_current); // Annahme: Es gibt ein "aktuelles" Level Cap
            
            if (currentLevelCap) {
                display.textContent = `Nächstes Level Cap: ${currentLevelCap.max_level} (Angepasst: ${currentLevelCap.adjusted_level})`;
            } else {
                display.textContent = 'Level Cap Daten nicht verfügbar.';
            }
        }


        function populateRouteSelects() {
            const newRouteSelect = $('#newRouteName');
            const routeToRemoveSelect = $('#routeToRemove');

            newRouteSelect.empty().append('<option></option>'); // Placeholder
            routeToRemoveSelect.empty().append('<option></option>'); // Placeholder

            // Füge alle Routennamen aus der Konfiguration hinzu
            allRouteNames.forEach(name => {
                // Füge nur Routen hinzu, die noch nicht in der DB sind
                if (!routes.some(r => r.name === name)) {
                    newRouteSelect.append(new Option(name, name));
                }
            });

            // Füge alle bereits hinzugefügten Routen zur "Entfernen"-Dropdown hinzu
            routes.forEach(route => {
                routeToRemoveSelect.append(new Option(route.name, route.id));
            });

            newRouteSelect.select2({
                theme: "bootstrap-5",
                width: $(this).data('width') ? $(this).data('width') : $(this).hasClass('w-100') ? '100%' : 'style',
                placeholder: $(this).data('placeholder'),
                dropdownParent: newRouteSelect.parent()
            });
            routeToRemoveSelect.select2({
                theme: "bootstrap-5",
                width: $(this).data('width') ? $(this).data('width') : $(this).hasClass('w-100') ? '100%' : 'style',
                placeholder: $(this).data('placeholder'),
                dropdownParent: routeToRemoveSelect.parent()
            });
        }


        // --- API-Aufrufe (Frontend-Logik) ---
        async function addPlayer() {
            const playerName = document.getElementById('newPlayerName').value.trim();
            if (!playerName) {
                showMessage('error', 'Bitte geben Sie einen Spielernamen ein.');
                return;
            }
            try {
                const response = await fetch('/api/add_player', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: playerName })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim Hinzufügen des Spielers');
                }
                document.getElementById('newPlayerName').value = '';
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim Hinzufügen des Spielers:', error);
                showMessage('error', error.message);
            }
        }

        async function addRoute() {
            const routeName = $('#newRouteName').val(); // Select2 holt den Wert
            if (!routeName) {
                showMessage('error', 'Bitte wählen Sie eine Route aus.');
                return;
            }
            try {
                const response = await fetch('/api/add_route', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: routeName })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim Hinzufügen der Route');
                }
                $('#newRouteName').val(null).trigger('change'); // Select2 zurücksetzen
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim Hinzufügen der Route:', error);
                showMessage('error', error.message);
            }
        }

        async function toggleGlobalOrder(orderNumber) {
            try {
                const response = await fetch('/api/toggle_global_order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ order_number: orderNumber })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim Umschalten des Ordensstatus');
                }
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim Umschalten des Ordensstatus:', error);
                showMessage('error', error.message);
            }
        }

        function confirmResetAllData() {
            if (confirm('Sind Sie sicher, dass Sie ALLE Pokémon-Fänge und Routen-Stati zurücksetzen möchten? Diese Aktion kann nicht rückgängig gemacht werden.')) {
                resetAllData();
            }
        }

        async function resetAllData() {
            try {
                const response = await fetch('/api/reset_all_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim Zurücksetzen der Daten');
                }
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim Zurücksetzen aller Daten:', error);
                showMessage('error', error.message);
            }
        }

        function confirmClearRouteData(routeId = null) {
            let idToClear = routeId;
            if (idToClear === null) {
                idToClear = $('#routeToRemove').val();
                if (!idToClear) {
                    showMessage('error', 'Bitte wählen Sie eine Route zum Entfernen aus.');
                    return;
                }
            }

            const routeName = routes.find(r => r.id == idToClear)?.name || 'diese Route';
            if (confirm(`Sind Sie sicher, dass Sie die Route "${routeName}" und alle zugehörigen Fänge löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.`)) {
                clearRouteData(idToClear);
            }
        }

        async function clearRouteData(routeId) {
            try {
                const response = await fetch('/api/clear_route_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ route_id: routeId })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim Löschen der Route');
                }
                $('#routeToRemove').val(null).trigger('change'); // Select2 zurücksetzen
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim Löschen der Route:', error);
                showMessage('error', error.message);
            }
        }

        function confirmFullDbReset() {
            if (confirm('WARNUNG: Sind Sie sicher, dass Sie die GESAMTE Datenbank vollständig zurücksetzen möchten? Dies löscht ALLE Spieler, Routen, Fänge und Konfigurationen und kann NICHT rückgängig gemacht werden!')) {
                fullDbReset();
            }
        }

        async function fullDbReset() {
            try {
                const response = await fetch('/api/full_db_reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim vollständigen Datenbank-Reset');
                }
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim vollständigen Datenbank-Reset:', error);
                showMessage('error', error.message);
            }
        }

        // --- NEUE STRING EXPORT/IMPORT FUNKTIONEN ---
        async function exportAllDataAsString() {
            const exportTextArea = document.getElementById('exportDataString');
            exportTextArea.value = 'Exportiere Daten... Bitte warten...';
            try {
                const response = await fetch('/api/export_all_data_string', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (!response.ok) {
                    const errorResult = await response.json();
                    throw new Error(errorResult.error || 'Fehler beim Exportieren der Daten als String.');
                }
                const data = await response.json();
                // Formatieren des JSON-Strings für bessere Lesbarkeit
                exportTextArea.value = JSON.stringify(data, null, 2); 
                showMessage('success', 'Daten erfolgreich als String exportiert.');
            } catch (error) {
                console.error('Fehler beim Exportieren der Daten als String:', error);
                exportTextArea.value = `Fehler beim Export: ${error.message}`;
                showMessage('error', `Fehler beim Export: ${error.message}`);
            }
        }

        function copyExportString() {
            const exportTextArea = document.getElementById('exportDataString');
            exportTextArea.select();
            exportTextArea.setSelectionRange(0, 99999); // Für mobile Geräte
            document.execCommand('copy');
            showMessage('success', 'Exportierter String in die Zwischenablage kopiert.');
        }

        function confirmImportDataAsString() {
            if (confirm('WARNUNG: Sind Sie sicher, dass Sie Daten aus dem String importieren möchten? Dies überschreibt ALLE aktuellen Daten in der Anwendung und kann NICHT rückgängig gemacht werden!')) {
                importAllDataAsString();
            }
        }

        async function importAllDataAsString() {
            const importString = document.getElementById('importDataString').value.trim();
            const password = document.getElementById('importPassword').value;

            if (!importString) {
                showMessage('error', 'Bitte fügen Sie einen Daten-String zum Importieren ein.');
                return;
            }
            if (!password) {
                showMessage('error', 'Bitte geben Sie das Import-Passwort ein.');
                return;
            }

            try {
                const response = await fetch('/api/import_all_data_string', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data_string: importString, password: password })
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Fehler beim Importieren der Daten aus String.');
                }
                document.getElementById('importDataString').value = ''; // Textfeld leeren
                document.getElementById('importPassword').value = ''; // Passwortfeld leeren
                // fetchDataAndRender() wird durch SocketIO-Event ausgelöst
                showMessage('success', result.message);
            } catch (error) {
                console.error('Fehler beim Importieren der Daten aus String:', error);
                showMessage('error', error.message);
            }
        }


        // --- Socket.IO Events ---
        socket.on('connect', () => {
            console.log('Verbunden mit Socket.IO');
        });

        socket.on('disconnect', () => {
            console.log('Verbindung zu Socket.IO getrennt');
        });

        socket.on('player_added', (data) => {
            console.log('Spieler hinzugefügt:', data);
            fetchDataAndRender();
        });

        socket.on('route_added', (data) => {
            console.log('Route hinzugefügt:', data);
            fetchDataAndRender();
        });

        socket.on('catch_updated', (data) => {
            console.log('Fang aktualisiert:', data);
            // Finde den aktualisierten Fang und aktualisiere ihn im lokalen Array
            const index = catches.findIndex(c => c.player_id === data.player_id && c.route_id === data.route_id);
            if (index !== -1) {
                catches[index].pokemon_name = data.pokemon_name;
            } else {
                // Falls der Eintrag neu ist (sollte nicht passieren, da sie initialisiert werden)
                catches.push(data);
            }
            renderTable(); // Tabelle neu rendern, um die Änderung zu zeigen
        });

        socket.on('global_order_toggled', (data) => {
            console.log('Globaler Orden-Status umgeschaltet:', data);
            const order = globalOrders.find(o => o.order_number === data.order_number);
            if (order) {
                order.is_obtained = data.is_obtained;
            }
            renderGlobalOrders();
        });

        socket.on('route_status_updated', (data) => {
            console.log('Routenstatus aktualisiert:', data);
            const route = routes.find(r => r.id === data.route_id);
            if (route) {
                route.status = data.status_text;
            }
            renderTable(); // Tabelle neu rendern, um den Status zu aktualisieren
        });

        socket.on('all_data_reset', () => {
            console.log('Alle Daten zurückgesetzt');
            fetchDataAndRender();
            showMessage('success', 'Alle Pokémon-Fänge und Routen-Stati zurückgesetzt.');
        });

        socket.on('route_deleted', (data) => {
            console.log('Route gelöscht:', data);
            fetchDataAndRender();
            showMessage('success', `Route mit ID ${data.route_id} gelöscht.`);
        });

        socket.on('full_db_reset', () => {
            console.log('Vollständiger Datenbank-Reset');
            fetchDataAndRender();
            showMessage('success', 'Datenbank vollständig zurückgesetzt.');
        });

        socket.on('config_saved', (data) => {
            console.log(`Konfigurationsdatei ${data.filename} gespeichert.`);
            // Wenn routes.json oder pokemon_names.json gespeichert werden, müssen wir reload_app_configs triggern
            // Dies geschieht bereits serverseitig, aber ein erneutes Laden der Daten ist gut.
            fetchDataAndRender(); 
            showMessage('success', `Datei ${data.filename} erfolgreich gespeichert.`);
        });

        socket.on('configs_reloaded', () => {
            console.log('App-Konfigurationen neu geladen.');
            fetchDataAndRender(); // Daten neu laden, um die aktualisierten Listen zu erhalten
            showMessage('success', 'App-Konfigurationen neu geladen.');
        });

        socket.on('import_completed', () => {
            console.log('Import abgeschlossen.');
            fetchDataAndRender(); // Daten nach Import neu laden
            showMessage('success', 'Daten erfolgreich aus String wiederhergestellt.');
        });

        // Initiales Laden der Daten
        document.addEventListener('DOMContentLoaded', fetchDataAndRender);
    </script>
</body>
</html>